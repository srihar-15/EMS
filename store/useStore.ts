
import { create } from 'zustand';
import { Employee, LeaveRequest, Role, LeaveStatus, AuditLog, PerformanceReview, Notification, AttendanceRecord, DepartmentBudget } from '../types';
import { INITIAL_EMPLOYEES, INITIAL_LEAVES, INITIAL_LOGS, INITIAL_REVIEWS, INITIAL_NOTIFICATIONS, INITIAL_ATTENDANCE, INITIAL_BUDGETS } from '../services/mockData';
import { api } from '../client/src/services/api';

interface AppState {
  user: Employee | null;
  employees: Employee[];
  leaves: LeaveRequest[];
  logs: AuditLog[];
  reviews: PerformanceReview[];
  notifications: Notification[];
  attendance: AttendanceRecord[];
  budgets: DepartmentBudget[];
  
  isLoading: boolean;
  
  // Actions
  fetchInitialData: () => Promise<void>;
  login: (email: string) => boolean;
  logout: () => void;
  
  // Modifiers
  addEmployee: (emp: Employee) => Promise<void>;
  updateEmployee: (id: string, updates: Partial<Employee>) => Promise<void>;
  deleteEmployee: (id: string) => Promise<void>;
  addLeaveRequest: (req: LeaveRequest) => Promise<void>;
  updateLeaveStatus: (id: string, status: LeaveStatus) => Promise<void>;
  addPerformanceReview: (review: PerformanceReview) => Promise<void>;
  updateDepartmentBudget: (department: string, amount: number) => Promise<void>;
  
  // Attendance
  checkIn: (employeeId: string) => Promise<void>;
  checkOut: (employeeId: string) => Promise<void>;
  
  // Notifications
  addNotification: (userId: string, message: string, type: 'info' | 'success' | 'warning' | 'error') => void;
  markNotificationRead: (id: string) => void;
  clearNotifications: () => void;

  logAction: (action: string, target: string, details?: string) => void;
}

export const useStore = create<AppState>((set, get) => ({
  user: null,
  employees: INITIAL_EMPLOYEES,
  leaves: INITIAL_LEAVES,
  logs: INITIAL_LOGS,
  reviews: INITIAL_REVIEWS,
  notifications: INITIAL_NOTIFICATIONS,
  attendance: INITIAL_ATTENDANCE,
  budgets: INITIAL_BUDGETS,
  isLoading: false,

  fetchInitialData: async () => {
    set({ isLoading: true });
    try {
        const data = await api.init();
        console.log("Connected to Backend API");
        set({
            employees: data.employees.length ? data.employees : INITIAL_EMPLOYEES,
            leaves: data.leaves.length ? data.leaves : INITIAL_LEAVES,
            logs: data.logs.length ? data.logs : INITIAL_LOGS,
            reviews: data.reviews,
            attendance: data.attendance,
            budgets: data.budgets.length ? data.budgets : INITIAL_BUDGETS,
            notifications: data.notifications,
            isLoading: false
        });
    } catch (error) {
        console.warn("Backend unavailable, using Mock Data.");
        // We do NOT re-throw here. We explicitly allow the app to run in "Offline/Mock" mode.
        set({ isLoading: false });
    }
  },

  login: (email: string) => {
    // For demo: Find employee by email in local state (which might be from backend)
    const emp = get().employees.find(e => e.email === email);
    if (emp) {
      set({ user: emp });
      // Store ID as token for the API service to use
      localStorage.setItem('nexus_token', emp.id);
      localStorage.setItem('nexus_user', JSON.stringify(emp));
      return true;
    }
    return false;
  },

  logout: () => {
      localStorage.removeItem('nexus_token');
      localStorage.removeItem('nexus_user');
      set({ user: null });
  },

  addEmployee: async (emp) => {
    try {
        // Remove temp ID if it was generated by frontend
        const { id, ...data } = emp;
        const saved = await api.employees.create(data);
        set(state => ({ employees: [...state.employees, saved] }));
        get().logAction('ADD_EMPLOYEE', emp.name, `Added to ${emp.department}`);
    } catch (e) {
        console.error("API Error (Fallback to Local):", e);
        // Optimistic / Fallback
        set(state => ({ employees: [...state.employees, emp] }));
    }
  },

  updateEmployee: async (id, updates) => {
    try {
        const saved = await api.employees.update(id, updates);
        set(state => ({
            employees: state.employees.map(e => e.id === id ? { ...e, ...saved } : e)
        }));
    } catch (e) {
        console.error("API Error:", e);
        // Fallback
        set(state => ({
            employees: state.employees.map(e => e.id === id ? { ...e, ...updates } : e)
        }));
    }
  },

  deleteEmployee: async (id) => {
    try {
        await api.employees.delete(id);
        set(state => ({ employees: state.employees.filter(e => e.id !== id) }));
    } catch (e) { 
        console.error("API Error:", e);
        set(state => ({ employees: state.employees.filter(e => e.id !== id) }));
    }
  },

  addLeaveRequest: async (req) => {
    try {
        const { id, ...data } = req;
        const saved = await api.leaves.create(data);
        set(state => ({ leaves: [saved, ...state.leaves] }));
        
        // Notify HR (Local Optimistic Update)
        const hrUsers = get().employees.filter(e => e.role === Role.HR);
        hrUsers.forEach(hr => get().addNotification(hr.id, `New ${req.type} leave request`, 'info'));
    } catch (e) { 
        console.error("API Error:", e);
        set(state => ({ leaves: [req, ...state.leaves] }));
    }
  },

  updateLeaveStatus: async (id, status) => {
      // Optimistic update first to ensure UI responsiveness
      const originalLeaves = get().leaves;
      set(state => ({
          leaves: state.leaves.map(l => l.id === id ? { ...l, status } : l)
      }));

      try {
          let saved;
          if (status === LeaveStatus.APPROVED) {
              const leave = get().leaves.find(l => l.id === id);
              // Simple check for L1 vs L2
              if (leave && leave.status === 'PENDING') {
                   saved = await api.leaves.approveL1(id);
              } else {
                   saved = await api.leaves.approveL2(id);
              }
          } else {
              saved = await api.leaves.reject(id, "Admin/HR Action");
          }
          
          // If successful, we might get updated data
          if (saved) {
             set(state => ({
                leaves: state.leaves.map(l => l.id === id ? saved : l)
             }));
          }

      } catch (e) { 
          console.error("API Error:", e);
          // If strict consistency is needed, revert here. 
          // For demo, we keep the optimistic update.
      }
  },

  addPerformanceReview: async (review) => {
      try {
          const { id, ...data } = review;
          const saved = await api.performance.create(data);
          set(state => ({ reviews: [saved, ...state.reviews] }));
      } catch (e) { 
          console.error("API Error:", e);
          set(state => ({ reviews: [review, ...state.reviews] }));
      }
  },

  updateDepartmentBudget: async (department, amount) => {
      set(state => ({
          budgets: state.budgets.map(b => b.department === department ? { ...b, allocated: amount } : b)
      }));
  },

  checkIn: async (employeeId) => {
      try {
          const saved = await api.attendance.checkIn();
          set(state => ({ attendance: [saved, ...state.attendance] }));
      } catch (e) { console.error("API Error:", e); }
  },

  checkOut: async (employeeId) => {
      try {
          const saved = await api.attendance.checkOut();
          set(state => ({ 
              attendance: state.attendance.map(r => r.id === saved.id ? saved : r)
          }));
      } catch (e) { console.error("API Error:", e); }
  },

  addNotification: (userId, message, type) => {
    // Local state only for now
    const newNotif = {
        id: Date.now().toString(),
        userId,
        message,
        type,
        isRead: false,
        timestamp: new Date().toISOString()
    };
    set(state => ({ notifications: [newNotif, ...state.notifications] }));
  },

  markNotificationRead: async (id) => {
      try {
          await api.notifications.markRead(id);
          set(state => ({
              notifications: state.notifications.map(n => n.id === id ? { ...n, isRead: true } : n)
          }));
      } catch(e) { 
          // Fallback
          set(state => ({
              notifications: state.notifications.map(n => n.id === id ? { ...n, isRead: true } : n)
          }));
      }
  },

  clearNotifications: () => {
    const { user } = get();
    if (user) {
        set(state => ({ notifications: state.notifications.filter(n => n.userId !== user.id) }));
    }
  },

  logAction: (action, target, details) => {
      const { user, logs } = get();
      const newLog: AuditLog = {
          id: Date.now().toString(),
          userId: user?.id || 'sys',
          userName: user?.name || 'System',
          userRole: user?.role || Role.ADMIN,
          action,
          target,
          timestamp: new Date().toISOString(),
          details
      };
      set({ logs: [newLog, ...logs] });
  }

}));
